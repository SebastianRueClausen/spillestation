//! This module handles drawing to the screen. It uses wgpu for hardware accelaration for both
//! rendering and computing a drawable image from the Playstations VRAM.

pub mod compute;
pub mod draw;

use compute::ComputeStage;
use draw::DrawStage;

use crate::gpu::Vram;

use winit::window::Window;

pub use compute::DrawInfo;

/// This is the texture drawn to the screen each frame. This is generated by
/// ['ComputePipeline'] and drawn by ['RenderPipeline'].
pub struct Canvas {
    view: wgpu::TextureView,
    extent: wgpu::Extent3d,
}

/// The format of ['Canvas'].
pub const CANVAS_FORMAT: wgpu::TextureFormat = wgpu::TextureFormat::Rgba16Float;

impl Canvas {
    /// Creates a new canvas with no data written to it.
    pub fn new(device: &wgpu::Device, surface_size: SurfaceSize) -> Self {
        let SurfaceSize { width, height } = surface_size;
        let extent = wgpu::Extent3d {
            width,
            height,
            depth_or_array_layers: 1,
        };
        let texture = device.create_texture(&wgpu::TextureDescriptor {
            label: Some("Render Texture"),
            size: extent,
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: CANVAS_FORMAT,
            // I'm a bit unsure which usage flags would be optimal. Maybe COPY_DST, but it's not
            // really copied to but written to pixel by pixel by the compute shader. But it doesn't
            // seem to change performance really, so perhaps it doesn't matter.
            usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::STORAGE_BINDING,
        });
        let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
        Self { view, extent }
    }
}

/// The size of a surface in pixels.
#[derive(Clone, Copy)]
pub struct SurfaceSize {
    pub width: u32,
    pub height: u32,
}

impl SurfaceSize {
    pub fn new(width: u32, height: u32) -> Self {
        Self { width, height }
    }
}

pub struct Renderer {
    pub device: wgpu::Device,
    pub queue: wgpu::Queue,
    pub surface_format: wgpu::TextureFormat,
    pub surface_size: SurfaceSize,
    surface: wgpu::Surface,
    canvas: Canvas,
    draw_stage: DrawStage,
    compute_stage: ComputeStage,
}

impl Renderer {
    pub fn new(window: &Window) -> Self {
        let (width, height) = (window.inner_size().width, window.inner_size().height);
        let instance = wgpu::Instance::new(wgpu::Backends::all());
        let surface = unsafe { instance.create_surface(window) };
        let adapter = pollster::block_on(instance.request_adapter(&wgpu::RequestAdapterOptions {
            power_preference: wgpu::PowerPreference::default(),
            compatible_surface: Some(&surface),
            force_fallback_adapter: false,
        }))
        .expect("Failed to find adapter");
        let (device, queue) = pollster::block_on(adapter.request_device(
            &wgpu::DeviceDescriptor {
                label: None,
                features: wgpu::Features::empty(),
                limits: wgpu::Limits::default(),
            },
            None,
        ))
        .expect("Failed find suitable render device");
        let surface_format = surface.get_preferred_format(&adapter).unwrap();
        let surface_size = SurfaceSize { width, height };
        surface.configure(
            &device,
            &wgpu::SurfaceConfiguration {
                usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
                format: surface_format,
                width,
                height,
                present_mode: wgpu::PresentMode::Mailbox,
            },
        );
        let canvas = Canvas::new(&device, SurfaceSize::new(640, 480));
        let compute_stage = ComputeStage::new(&device, &canvas);
        let draw_stage = DrawStage::new(&device, surface_size, surface_format, &canvas);
        Self {
            device,
            queue,
            surface,
            surface_format,
            surface_size,
            canvas,
            draw_stage,
            compute_stage,
        }
    }

    /// The main function used to render stuff. It prepares everything from wgpu needed to start
    /// rendering, runs the render function, and finally it submit's the commands and present's the
    /// rendered frame.
    pub fn render<F>(&self, func: F)
    where
        F: FnOnce(&mut wgpu::CommandEncoder, &wgpu::TextureView, &Self),
    {
        let frame = self
            .surface
            .get_current_texture()
            .or_else(|err| match err {
                wgpu::SurfaceError::Outdated => {
                    // Update the surface if it's outdated.
                    self.configure_surface();
                    self.surface.get_current_texture()
                }
                _ => panic!("Surface Error {}", err),
            })
            .expect("Failed to get surface");
        let mut encoder = self
            .device
            .create_command_encoder(&wgpu::CommandEncoderDescriptor {
                label: Some("Render Encoder")
            });
        let view = frame
            .texture
            .create_view(&wgpu::TextureViewDescriptor::default());
        self.draw_stage.render_canvas(&mut encoder, &view);
        func(&mut encoder, &view, self);
        self.queue.submit(Some(encoder.finish()));
        frame.present();
    }

    /// Configures the surface. This needs to be called if the size of the window changes.
    fn configure_surface(&self) {
        self.surface.configure(
            &self.device,
            &wgpu::SurfaceConfiguration {
                usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
                format: self.surface_format,
                width: self.surface_size.width,
                height: self.surface_size.height,
                present_mode: wgpu::PresentMode::Fifo,
            },
        );
    }

    pub fn resize(&mut self, surface_size: SurfaceSize) {
        if surface_size.width != 0 && surface_size.height != 0 {
            self.surface_size = surface_size;
            self.configure_surface();
            self.draw_stage.resize(&self.queue, surface_size, &self.canvas);
        }
    }

    pub fn send_frame(&self, info: DrawInfo, vram: &Vram) {
        let mut encoder = self
            .device
            .create_command_encoder(&wgpu::CommandEncoderDescriptor {
                label: Some("Canvas Compute Encoder")
            });
        self.compute_stage.compute_canvas(
            vram,
            &info,
            &mut encoder,
            &self.queue,
            &self.canvas,
        );
        self.queue.submit(Some(encoder.finish()));
    }
}
